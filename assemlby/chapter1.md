## The parts of an elf file

First of all we need to know that binaries in linux are elf files. These files are separated into sections, which you can see with the info file command in the gdb, some of which are the following:


|   Name   |                                            description                                                          |
|---------:|-----------------------------------------------------------------------------------------------------------------|
|.interp   |In this section there is a path to a dynamic loader (it is a helper program that helps load shared libraries with the program, prepares the progam, and loads it)                                                                              |
|.rodata   |In this section there is data that cannot be modified (such as const variables)                                  |
|.data     |In this section there is data that has been initialized and is modifiable (such as global variables)             |
|.bss      |In this section there is data that has not been initialized such as global variables, at the start you will only see empty space                                                                                                              |
|.text     |In this section there is only code to be executed                                                                |

You may ask where are the other variables in your code, well they do not "exist" until your program runs. Any variable inside of the code is simply a number or empty space in the .text area awaiting to be executed.

Now we will look into an example of this through the gcc assemlber. But before that i would like to talk about assemlby itself a little, specificaly about directives.They are parts of the assemlby code that start with a dot. Each one has different effects such as inserting data into the file or changing the permissions of the code, some of these are:

```asm
.data
; Transforms the current section into a data section.
.text
; Transforms the current section into a text section.
.string "example"
; Allocates directly into the code a string "example" as a 0 ended sequence of bytes.
.globl name
; Tells the linker that an object "name" is global (it can be seen by the rest of the code even if it is not in the same file) (it also creates the object)
.type name, @type
; Tells the assemlber what type the object "name" is (@object,@function)
.size name,bytes
; Tells the assemlber the size in bytes of the object "name"
.section .rodata
; Transforms the current section into a read only data section.
.bss
; Transforms the current section into a text section.
```

Also we should talk about lables, which are a string that are used to reference places in memory: the value of the label is the location of the first operation in the assemlby. There are global labels (typed "name":) and local labels (typed ".name":). The diffenece is that global ones are put in the objects file symbol table and the latter does not.


Here the example, a simple hello world with some extra unnecessary variables:

```c
const int a = 0x20202020;
int b = 0x10101010;
long long c;
int main(){
    int d;
    int e = 2;
    printf("hellothere");
    return 0;
}
```

Now let's see part of the s file generated by the command gcc -masm=intel -S hello_world.c

```asm
        .globl	a
        .section	.rodata
        .align 4
        .type	a, @object
        .size	a, 4
    a:
        .long	538976288
        .globl	b
        .data
        .align 4
        .type	b, @object
        .size	b, 4
    b:
        .long	269488144
        .globl	c
        .bss
        .align 8
        .type	c, @object
        .size	c, 8
    c:
        .zero	8
        .section	.rodata
    .LC0:
        .string	"hellothere"
        .text
        .globl	main
        .type	main, @function
    main:
        endbr64
        push	rbp
        mov	rbp, rsp
        sub	rsp, 16
        mov	DWORD PTR -4[rbp], 2
        lea	rax, .LC0[rip]
        mov	rdi, rax
        mov	eax, 0
        call	printf@PLT
        mov	eax, 0
        leave
        ret

```

We can see almost all of the variables that we used in the code, and each one in their respective places. a is in rodata, b is in data, c is in bss, and even the string "hellothere" is in rodata. now you may notice that d is not there, and that is because it was not global and we never initialized it, so space is never allocated for it and it is as if it did not exist. You may also think that e disappeared as well but that is not the case